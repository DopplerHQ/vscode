import * as vscode from "vscode";
import * as yaml from "yaml";
import * as helpers from "../helpers";
import * as doppler from "../doppler";
import { TextEncoder, TextDecoder } from "util";

export default class DopplerFileSystemProvider implements vscode.FileSystemProvider {
  // Required part of the FileSystemProvider interface
  private _emitter = new vscode.EventEmitter<vscode.FileChangeEvent[]>();
  readonly onDidChangeFile: vscode.Event<vscode.FileChangeEvent[]> = this._emitter.event;

  async fetchSecrets(project: string, config: string) {
    const secrets = await doppler.secrets.fetchRaw(project, config);

    // Filter out Doppler reserved
    for (const name of ["PROJECT", "ENVIRONMENT", "CONFIG"]) {
      delete secrets[`DOPPLER_${name}`];
    }

    return secrets;
  }

  generateYAMLMessage() {
    const padding = 3;
    const lines = [
      "This file was generated by Doppler. When you make",
      "changes to this file, they will be saved to your",
      "config in Doppler as well.",
    ];
    const longestLineLength = Math.max(...lines.map((el) => el.length)) + 1;
    const paddingSpaces = Array(padding).join(" ");
    const borderLeftRight = "##";
    const formattedLines = lines.map(function (line) {
      return [
        borderLeftRight,
        paddingSpaces,
        line + Array(longestLineLength - line.length).join(" "),
        paddingSpaces,
        borderLeftRight,
      ].join("");
    });

    const bordersTopBottom = Array(formattedLines[0].length + 1).join("#");
    return [bordersTopBottom, ...formattedLines, bordersTopBottom].join("\n");
  }

  jsonToYAML(secrets: doppler.DopplerSecrets) {
    const comment = this.generateYAMLMessage();
    const yamlFile = yaml.stringify(secrets, null, {
      indent: 2,
      sortMapEntries: true,
    });

    return `${comment}\n\n${yamlFile}`;
  }

  async stat(uri: vscode.Uri) {
    const content = await this.readFile(uri);

    return {
      type: vscode.FileType.File,
      size: content.length,
      ctime: Date.now(),
      mtime: Date.now(),
    };
  }

  async readFile(uri: vscode.Uri) {
    const { project, config } = helpers.parser.fromURI(uri);
    const content = this.jsonToYAML(await this.fetchSecrets(project, config));
    return new TextEncoder().encode(content);
  }

  async writeFile(uri: vscode.Uri, content: Uint8Array, options: { create: boolean; overwrite: boolean }) {
    const { project, config } = helpers.parser.fromURI(uri);
    const existing_secrets = await this.fetchSecrets(project, config);
    const new_secrets = yaml.parse(new TextDecoder().decode(content)) as doppler.DopplerSecrets;
    const changed_secrets: doppler.DopplerSecretsUpdate = {};

    // Detect changes
    for (const [name, value] of Object.entries(new_secrets)) {
      if (existing_secrets[name] !== value) {
        changed_secrets[name] = value;
      }
    }

    // Mark deleted secrets as null
    for (const name of Object.keys(existing_secrets)) {
      if (new_secrets[name] === undefined) {
        changed_secrets[name] = null;
      }
    }

    // Save only if there are changes
    if (Object.keys(changed_secrets).length > 0) {
      await doppler.secrets.update(project, config, changed_secrets);
    }
  }

  watch(uri: vscode.Uri): vscode.Disposable {
    // ignore, fires for all changes...
    /* eslint @typescript-eslint/no-empty-function: "off" */
    return new vscode.Disposable(() => {});
  }

  async rename(oldUri: vscode.Uri, newUri: vscode.Uri, options: { overwrite: boolean }) {
    throw new Error("DopplerFileSystemProvider: Rename operations are not allowed");
  }

  async delete(uri: vscode.Uri) {
    throw new Error("DopplerFileSystemProvider: Delete operations are not allowed");
  }

  async createDirectory(uri: vscode.Uri) {
    throw new Error("DopplerFileSystemProvider: Create directory operations are not allowed");
  }

  async readDirectory(uri: vscode.Uri): Promise<[string, vscode.FileType][]> {
    throw new Error("DopplerFileSystemProvider: Read directory operations are not allowed");
  }
}
